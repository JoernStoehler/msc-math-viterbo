"""Skills utility: print, check, or fix.

Modes:
- --print (default): print skill summaries (name + description + optional suffix)
- --check: non-mutating checks for AGENTS.md autogenerated sections; also validates skill frontmatter
- --fix: update AGENTS.md autogenerated sections in-place

Exit codes:
- 0 on success (even if --check finds issues; it only warns)
- 2 if one or more skill files have invalid frontmatter (parsing errors)
"""

from __future__ import annotations

import argparse
import re
import sys
from collections.abc import Iterable
from pathlib import Path


def parse_frontmatter(content: str) -> dict[str, str]:
    """Return a dict of frontmatter key/value pairs."""
    lines = content.splitlines()
    if not lines or lines[0].strip() != "---":
        msg = "missing opening --- delimiter"
        raise ValueError(msg)

    fm_lines: list[str] = []
    for line in lines[1:]:
        if line.strip() == "---":
            break
        fm_lines.append(line.rstrip())
    else:
        msg = "missing closing --- delimiter"
        raise ValueError(msg)

    data: dict[str, str] = {}
    current_key: str | None = None
    for raw in fm_lines:
        if not raw.strip():
            continue

        if raw.startswith(" ") and current_key:
            # Continuation of a previous value (YAML folded style).
            data[current_key] = f"{data[current_key]} {raw.strip()}"
            continue

        if ":" not in raw:
            msg = f"invalid frontmatter entry: {raw!r}"
            raise ValueError(msg)

        key, value = raw.split(":", 1)
        key = key.strip()
        value = value.strip().strip('"').strip("'")
        data[key] = value
        current_key = key

    return data


def load_skill_metadata(path: Path) -> dict[str, str]:
    """Read and parse the metadata for a single skill file."""
    content = path.read_text(encoding="utf-8")
    metadata = parse_frontmatter(content)
    if "name" not in metadata:
        metadata["name"] = path.stem
    metadata.setdefault("description", "")
    return metadata


def format_metadata(metadata: dict[str, str]) -> str:
    """Collapse metadata into a single summary line."""
    name = metadata.get("name", "unknown")
    description = metadata.get("description", "").strip()
    suffix_parts: list[str] = []
    for optional in ("last-updated", "license"):
        value = metadata.get(optional)
        if value:
            suffix_parts.append(f"{optional}: {value}")

    suffix = f" ({'; '.join(suffix_parts)})" if suffix_parts else ""
    if description:
        return f"{name}: {description}{suffix}"
    return f"{name}{suffix}"


def iter_skill_files(skills_dir: Path) -> list[Path]:
    """Return all Markdown files directly under the skills directory."""
    return sorted(path for path in skills_dir.glob("*.md") if path.is_file())


# --- AGENTS.md integration -------------------------------------------------

BEGIN_OVERVIEW = "<!-- BEGIN: skills-overview (auto-generated) -->"
END_OVERVIEW = "<!-- END: skills-overview -->"
BEGIN_ALWAYS = "<!-- BEGIN: always-on-skills (auto-generated) -->"
END_ALWAYS = "<!-- END: always-on-skills -->"


def _truthy(value: str | None) -> bool:
    if value is None:
        return False
    return value.strip().lower() in {"1", "true", "yes", "y"}


def _is_always_on(meta: dict[str, str]) -> bool:
    if meta.get("relevance", "").strip().lower() == "always":
        return True
    if _truthy(meta.get("always")):
        return True
    if _truthy(meta.get("always-on")) or _truthy(meta.get("always_on")):
        return True
    return False


def _format_overview(skills: Iterable[tuple[Path, dict[str, str]]]) -> str:
    lines: list[str] = []
    for path, meta in skills:
        slug = meta.get("slug") or path.stem
        name = meta.get("name") or slug
        desc = meta.get("description", "").strip()
        last_updated = meta.get("last-updated") or meta.get("updated")
        suffix = f" (last-updated: {last_updated})" if last_updated else ""
        desc_part = f" — {desc}" if desc else ""
        lines.append(f"- `skills/{path.name}` — {name}{desc_part}{suffix}")
    return "\n".join(lines) if lines else "_no skills found_"


def _format_always_on(skills: Iterable[tuple[Path, dict[str, str]]]) -> str:
    items = []
    for path, meta in skills:
        if _is_always_on(meta):
            name = meta.get("name") or meta.get("slug") or path.stem
            items.append(f"- `skills/{path.name}` — {name}")
    if not items:
        return "_none marked as always-on; set `relevance: always` in frontmatter_"
    return "\n".join(items)


def _replace_block(content: str, begin: str, end: str, new_body: str) -> str:
    if begin in content and end in content:
        pre, rest = content.split(begin, 1)
        _, post = rest.split(end, 1)
        return f"{pre}{begin}\n{new_body}\n{end}{post}"
    # If markers are absent, append a new section at the end.
    section_title = (
        "## Skills Overview (Auto-Generated)"
        if "skills-overview" in begin
        else "## Always-On Skills (Auto-Generated)"
    )
    appended = f"\n\n{section_title}\n\n{begin}\n{new_body}\n{end}\n"
    return content + appended


def update_agents_md(agents_md: Path, skills: list[tuple[Path, dict[str, str]]]) -> None:
    content = agents_md.read_text(encoding="utf-8")
    maint = "<!-- This section is maintained by scripts/load_skills_metadata.py. Do not edit between markers. -->"
    overview_body = maint + "\n" + _format_overview(skills)
    always_body = maint + "\n" + _format_always_on(skills)
    content = _replace_block(content, BEGIN_OVERVIEW, END_OVERVIEW, overview_body)
    content = _replace_block(content, BEGIN_ALWAYS, END_ALWAYS, always_body)
    agents_md.write_text(content, encoding="utf-8")


def _get_block(text: str, begin: str, end: str) -> str | None:
    if begin not in text or end not in text:
        return None
    pre, rest = text.split(begin, 1)
    body, _ = rest.split(end, 1)
    return body.strip()


def _looks_empty(body: str | None) -> bool:
    if body is None:
        return True
    lines = [ln.strip() for ln in body.splitlines() if ln.strip()]
    lines = [ln for ln in lines if not ln.startswith("<!--") and not ln.endswith("-->")]
    if not lines:
        return True
    placeholders = {
        "_pending — run `just setup` to populate._",
        "_none marked as always-on; set `relevance: always` in frontmatter_",
        "_no skills found_",
    }
    if any(ph in " ".join(lines) for ph in placeholders):
        return True
    # Consider empty if no bullets remain
    if not any(ln.startswith("-") for ln in lines):
        return True
    return False


def _normalize_preserve(s: str) -> str:
    """Normalize newlines (preserve trailing spaces)."""
    return s.replace("\r\n", "\n").replace("\r", "\n")


def _normalize_heavy(s: str) -> str:
    """Collapse internal whitespace to detect whitespace-only differences."""
    lines = [re.sub(r"\s+", " ", ln.strip()) for ln in s.splitlines()]
    return "\n".join(lines).strip()


def _bullet_lines(body: str) -> set[str]:
    return {ln.strip() for ln in body.splitlines() if ln.lstrip().startswith("-")}


def main(argv: list[str] | None = None) -> int:
    """Run the CLI that validates and summarizes skill metadata, and manages AGENTS.md."""
    parser = argparse.ArgumentParser(
        description="Skills utility: print, check, or fix AGENTS.md sections."
    )
    parser.add_argument(
        "--skills-dir",
        type=Path,
        default=Path("skills"),
        help="Directory containing skill markdown files",
    )
    parser.add_argument(
        "--agents-md", type=Path, default=Path("AGENTS.md"), help="AGENTS.md path to check or fix"
    )
    parser.add_argument("--quiet", action="store_true", help="Suppress summary output")
    parser.add_argument(
        "--print", dest="do_print", action="store_true", help="Print skill summaries"
    )
    parser.add_argument(
        "--check", dest="do_check", action="store_true", help="Non-mutating AGENTS.md checks"
    )
    parser.add_argument(
        "--fix",
        dest="do_fix",
        action="store_true",
        help="Update AGENTS.md autogenerated sections in-place",
    )
    args = parser.parse_args(argv)

    skills_dir: Path = args.skills_dir
    if not skills_dir.exists():
        sys.stderr.write(f"no skills directory at {skills_dir}\n")
        return 1

    skill_files = iter_skill_files(skills_dir)
    errors: list[tuple[Path, Exception]] = []
    summaries: list[str] = []
    loaded: list[tuple[Path, dict[str, str]]] = []
    for path in skill_files:
        try:
            metadata = load_skill_metadata(path)
        except Exception as exc:  # noqa: BLE001 - surface metadata issues
            errors.append((path, exc))
            continue
        summaries.append(format_metadata(metadata))
        loaded.append((path, metadata))

    # Default behavior: print summaries if no explicit mode is requested
    default_to_print = not (args.do_check or args.do_fix or args.do_print)
    if args.do_print or default_to_print:
        if not args.quiet:
            for summary in summaries:
                sys.stdout.write(f"{summary}\n")

    # Non-mutating checks
    if args.do_check:
        if not args.agents_md.exists():
            sys.stderr.write("[warn] AGENTS.md: file not found\n")
        else:
            text = args.agents_md.read_text(encoding="utf-8")
            overview = _get_block(text, BEGIN_OVERVIEW, END_OVERVIEW)
            always = _get_block(text, BEGIN_ALWAYS, END_ALWAYS)
            maint = "<!-- This section is maintained by scripts/load_skills_metadata.py. Do not edit between markers. -->"
            gen_overview = maint + "\n" + _format_overview(loaded)
            gen_always = maint + "\n" + _format_always_on(loaded)
            if overview is None:
                sys.stderr.write("[warn] AGENTS.md: missing skills-overview section markers\n")
            elif _looks_empty(overview):
                sys.stderr.write(
                    "[warn] AGENTS.md: skills-overview appears empty; refresh with --fix or run provisioning\n"
                )
            else:
                if _normalize_preserve(overview) != _normalize_preserve(gen_overview):
                    ob = _bullet_lines(overview)
                    gb = _bullet_lines(gen_overview)
                    if ob == gb:
                        sys.stderr.write(
                            "[warn] AGENTS.md: skills-overview differs only by whitespace; run --fix to normalize\n"
                        )
                    else:
                        added = len(gb - ob)
                        removed = len(ob - gb)
                        sys.stderr.write(
                            f"[warn] AGENTS.md: skills-overview out-of-date (added: {added}, removed: {removed}); run --fix to update\n"
                        )
            if always is None:
                sys.stderr.write("[warn] AGENTS.md: missing always-on-skills section markers\n")
            elif _looks_empty(always):
                sys.stderr.write(
                    "[warn] AGENTS.md: always-on-skills appears empty; mark skills with `relevance: always` or refresh with --fix\n"
                )
            else:
                if _normalize_preserve(always) != _normalize_preserve(gen_always):
                    ob = _bullet_lines(always)
                    gb = _bullet_lines(gen_always)
                    if ob == gb:
                        sys.stderr.write(
                            "[warn] AGENTS.md: always-on-skills differs only by whitespace; run --fix to normalize\n"
                        )
                    else:
                        added = len(gb - ob)
                        removed = len(ob - gb)
                        sys.stderr.write(
                            f"[warn] AGENTS.md: always-on-skills out-of-date (added: {added}, removed: {removed}); run --fix to update\n"
                        )

    # Mutating fix
    if args.do_fix:
        if not args.agents_md.exists():
            sys.stderr.write(f"[warn] {args.agents_md} not found; skipping --fix\n")
        else:
            update_agents_md(args.agents_md, loaded)

    for path, exc in errors:
        sys.stderr.write(f"[warn] {path}: {exc}\n")

    return 0 if not errors else 2


if __name__ == "__main__":
    sys.exit(main())
