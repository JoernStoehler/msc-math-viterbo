from typing import Any, Callable, Iterable, Iterator, Literal, ParamSpec, TypeVar, overload

P = ParamSpec("P")
R = TypeVar("R")

# Core Array type used by JAX. Minimal surface for static typing.
class Array:
    shape: tuple[int, ...]
    dtype: Any
    size: int
    ndim: int
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...

    # Simple methods/properties commonly used in this codebase
    def item(self) -> Any: ...
    def __array__(self, dtype: Any | None = ...) -> Any: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def astype(self, dtype: Any, *, copy: bool = ...) -> "Array": ...
    def reshape(self, *shape: Any, order: str | None = ...) -> "Array": ...
    def transpose(self, axes: Any | None = ...) -> "Array": ...
    @property
    def T(self) -> "Array": ...
    def tolist(self) -> list[Any]: ...

    # Index update helper (x.at[idx].set(...))
    class _IndexUpdate:
        def __getitem__(self, key: Any) -> "Array._IndexUpdate": ...
        def set(self, values: Any) -> "Array": ...
        def add(self, values: Any) -> "Array": ...
        def multiply(self, values: Any) -> "Array": ...

    @property
    def at(self) -> "Array._IndexUpdate": ...

    # Common dunder ops
    def __getitem__(self, key: Any) -> "Array": ...
    def __matmul__(self, other: "Array") -> "Array": ...
    def __add__(self, other: Any) -> "Array": ...
    def __sub__(self, other: Any) -> "Array": ...
    def __mul__(self, other: Any) -> "Array": ...
    def __truediv__(self, other: Any) -> "Array": ...
    def __neg__(self) -> "Array": ...
    def __radd__(self, other: Any) -> "Array": ...
    def __rsub__(self, other: Any) -> "Array": ...
    def __rmul__(self, other: Any) -> "Array": ...
    def __rtruediv__(self, other: Any) -> "Array": ...
    def __lt__(self, other: Any) -> "Array": ...
    def __le__(self, other: Any) -> "Array": ...
    def __gt__(self, other: Any) -> "Array": ...
    def __ge__(self, other: Any) -> "Array": ...
    def __eq__(self, other: Any) -> "Array": ...
    def __or__(self, other: Any) -> "Array": ...
    def __ror__(self, other: Any) -> "Array": ...

    # Common reduction methods
    def sum(self, axis: Any | None = ..., keepdims: bool = ...) -> "Array": ...
    def any(self, axis: Any | None = ..., keepdims: bool = ...) -> "Array": ...
    def all(self, axis: Any | None = ..., keepdims: bool = ...) -> "Array": ...
    def max(self, axis: Any | None = ..., keepdims: bool = ...) -> "Array": ...
    def copy(self) -> "Array": ...

# Expose submodules so imports like "import jax.numpy as jnp" type-check.
from . import lax as lax
from . import numpy as numpy
from . import random as random

def jit(f: Callable[P, R], *args: Any, **kwargs: Any) -> Callable[P, R]: ...
@overload
def value_and_grad(
    f: Callable[P, R],
    *,
    argnums: int | tuple[int, ...] = ...,
    has_aux: Literal[False] = ...,
) -> Callable[P, tuple[R, Any]]: ...
@overload
def value_and_grad(
    f: Callable[P, tuple[R, Any]],
    *,
    argnums: int | tuple[int, ...] = ...,
    has_aux: Literal[True],
) -> Callable[P, tuple[tuple[R, Any], Any]]: ...
def grad(
    f: Callable[..., Any],
    argnums: int | tuple[int, ...] = ...,
) -> Callable[..., Any]: ...
def vmap(
    f: Callable[P, R],
    in_axes: Any = ...,
    out_axes: Any = ...,
    axis_name: Any = ...,
) -> Callable[P, R]: ...
def tree_map(f: Callable[..., Any], *pytrees: Any, is_leaf: Any | None = ...) -> Any: ...
def tree_leaves(pytree: Any) -> list[Any]: ...
def tree_flatten(pytree: Any) -> tuple[list[Any], Any]: ...
def tree_unflatten(aux: Any, leaves: Iterable[Any]) -> Any: ...
