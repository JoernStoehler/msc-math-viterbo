from __future__ import annotations

from typing import Any, Sequence

from jax import Array as Array

# Dtype placeholders
class dtype: ...

float64: dtype
float32: dtype
int64: dtype
int32: dtype
uint32: dtype
bool_: dtype
inf: float
pi: float

def array(obj: Any, dtype: object | None = ..., copy: bool | None = ...) -> Array: ...
def asarray(obj: Any, dtype: object | None = ...) -> Array: ...
def zeros(shape: int | Sequence[int], dtype: object | None = ...) -> Array: ...
def empty(shape: int | Sequence[int], dtype: object | None = ...) -> Array: ...
def ones(shape: int | Sequence[int], dtype: object | None = ...) -> Array: ...
def full(shape: int | Sequence[int], fill_value: Any, dtype: object | None = ...) -> Array: ...
def zeros_like(a: Array, dtype: object | None = ...) -> Array: ...
def ones_like(a: Array, dtype: object | None = ...) -> Array: ...
def eye(N: int, M: int | None = ..., k: int = ..., dtype: object | None = ...) -> Array: ...
def identity(n: int, dtype: object | None = ...) -> Array: ...
def arange(
    start: int | float,
    stop: int | float | None = ...,
    step: int | float = ...,
    dtype: dtype | None = ...,
) -> Array: ...
def linspace(start: float, stop: float, num: int = ..., endpoint: bool = ..., dtype: dtype | None = ...) -> Array: ...
def concatenate(seq: Sequence[Array], axis: int | None = ...) -> Array: ...
def stack(seq: Sequence[Array], axis: int = ...) -> Array: ...
def vstack(seq: Sequence[Array]) -> Array: ...
def hstack(seq: Sequence[Array]) -> Array: ...
def block(arrays: Any) -> Array: ...
def repeat(a: Array, repeats: int | Sequence[int] | Array, axis: int | None = ...) -> Array: ...
def tile(a: Array, reps: int | Sequence[int]) -> Array: ...
def prod(a: Array, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ...) -> Array: ...
def transpose(a: Array, axes: Sequence[int] | None = ...) -> Array: ...
def reshape(a: Array, newshape: Sequence[int] | int, order: str = ...) -> Array: ...
def where(condition: Array | bool, x: Any = ..., y: Any = ...) -> Array: ...
def maximum(x1: Array | float, x2: Array | float) -> Array: ...
def minimum(x1: Array | float, x2: Array | float) -> Array: ...
def abs(x: Array | float) -> Array: ...
def sin(x: Array | float) -> Array: ...
def cos(x: Array | float) -> Array: ...
def sqrt(x: Array) -> Array: ...
def exp(x: Array | float) -> Array: ...
def log(x: Array | float) -> Array: ...
def log1p(x: Array | float) -> Array: ...
def square(x: Array) -> Array: ...
def clip(a: Array | float, a_min: Array | float | None, a_max: Array | float | None) -> Array: ...
def isclose(a: Any, b: Any, rtol: float = ..., atol: float = ...) -> Array: ...
def all(a: Array, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ...) -> Array: ...
def isfinite(x: Any) -> Array: ...
def allclose(a: Array | float, b: Array | float, rtol: float = ..., atol: float = ...) -> Array: ...
def any(a: Array, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ...) -> Array: ...
def logical_and(x1: Array, x2: Array) -> Array: ...
def logical_not(x: Array) -> Array: ...
def tril(m: Array, k: int = 0) -> Array: ...
def compress(condition: Array, a: Array, axis: int | None = ...) -> Array: ...
def lexsort(keys: Array | Sequence[Array], axis: int = ...) -> Array: ...
def argsort(a: Array, axis: int | None = ..., kind: str | None = ...) -> Array: ...
def take(a: Array, indices: Array | Sequence[int], axis: int | None = ...) -> Array: ...
def round(a: Array | float, decimals: int = ...) -> Array: ...
def sum(a: Array, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ...) -> Array: ...
def mean(a: Array, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ...) -> Array: ...
def max(a: Array, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ...) -> Array: ...
def min(a: Array, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ...) -> Array: ...
def dot(a: Array, b: Array, *, precision: Any | None = ...) -> Array: ...
def matmul(a: Array, b: Array, *, precision: Any | None = ...) -> Array: ...
def einsum(subscripts: str, *operands: Array, optimize: Any = ...) -> Array: ...
def diag_indices(n: int, ndim: int = ...) -> tuple[Array, ...]: ...
def diag(v: Array, k: int = ...) -> Array: ...
def ix_(*args: Array) -> tuple[Array, ...]: ...
def power(x1: Array | float, x2: Array | float) -> Array: ...

# Minimal ufunc placeholder with .outer attribute used in code
class _UFunc:
    def __call__(self, x1: Any, x2: Any, /, *args: Any, **kwargs: Any) -> Array: ...
    def outer(self, a: Any, b: Any, /, *args: Any, **kwargs: Any) -> Array: ...

multiply: _UFunc

# Compatibility alias sometimes used in annotations
ndarray = Array

# Submodule exports
from . import linalg as linalg
