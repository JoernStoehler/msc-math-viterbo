#!/usr/bin/env bash
set -euo pipefail

# agent — unified CLI for *this repo only* (no env/config required)
# Repo: ~/workspaces/msc-math-viterbo
# Host alias (ssh config): joern-pc
# No tmux. Works the same on phone (Termux) and Ubuntu host.
#
# Examples:
#   agent --connect                  # phone → mosh/ssh joern-pc
#   agent --up --shell               # ensure devcontainer, enter shell
#   agent --open feat-123 --codex    # ensure worktree, then run Codex inside container
#   agent --open pr:42 --shell       # open by PR number
#   agent --create exp-foo --shell   # new branch from main
#   agent --exec "pytest -q"         # one-off in container
#   agent --list                     # list worktrees
#   agent --remove feat-123 --force  # delete worktree/branch

# ---------- fixed repo/host settings (YAGNI: no env, no multi-repo) ----------
HOST_ALIAS="joern-pc"                          # must match ~/.ssh/config
MAIN_REPO_ROOT="$HOME/workspaces/msc-math-viterbo"
DEVCONF_REL=".devcontainer/local/devcontainer.json"
DEVCONTAINER_BIN="devcontainer"
CODEX_CMD_DEFAULT="codex --yolo --model gpt-5 --config model_reasoning_effort=high"
USE_MOSH_DEFAULT=1                              # use mosh on phone

# Computes writable agents root: prefer /workspaces (inside container), else .. near repo
choose_agents_root(){
  if [[ -d /workspaces && -w /workspaces ]]; then
    echo "/workspaces/msc-math-viterbo.agents"
  else
    echo "$MAIN_REPO_ROOT/../msc-math-viterbo.agents"
  fi
}
AGENTS_ROOT="$(choose_agents_root)"; mkdir -p "$AGENTS_ROOT" 2>/dev/null || true

# ---------- helpers ----------
usage(){ cat <<'EOF'
Usage: agent [flags]

Connect (phone; executes immediately):
  --connect            Connect via mosh (falls back to ssh if mosh missing)
  --ssh                Connect via plain ssh

Worktrees:
  --list               List worktrees under msc-math-viterbo.agents
  --open TOKEN         Ensure worktree exists and cd into it (TOKEN or pr:NUM)
  --create BRANCH      Create new branch+worktree from main
  --remove TOKEN       Remove worktree/branch (use with --force for dirty)
  --gc                 Remove orphaned dirs under agents root (use with --force)

Devcontainer actions (chainable, run after worktree ops):
  --up                 Ensure devcontainer is up for current worktree (or MAIN)
  --shell              Enter login shell inside the devcontainer
  --exec CMD           Run command in container and exit
  --codex [ARGS...]    Launch Codex in container (default: codex --yolo --model gpt-5 --config model_reasoning_effort=high)

Other:
  --force              Force for remove/gc
  --doctor             Check tools/paths
  --env                Print derived config
  -h, --help           Show help
EOF
}

is_termux(){ [[ "${PREFIX-}" == */com.termux/* ]]; }
require(){ command -v "$1" >/dev/null 2>&1 || { echo "ERROR: missing tool: $1" >&2; exit 127; }; }
abs_repo(){ cd "$MAIN_REPO_ROOT" 2>/dev/null && pwd; }
print_cfg(){ cat <<EOF
whoami=$(whoami)
HOST_ALIAS=$HOST_ALIAS
MAIN_REPO_ROOT=$MAIN_REPO_ROOT
DEVCONF_REL=$DEVCONF_REL
DEVCONTAINER_BIN=$DEVCONTAINER_BIN
AGENTS_ROOT=$AGENTS_ROOT
EOF
}


in_container(){ [[ -f /.dockerenv ]] || [[ -n "${DEVCONTAINER:-}" ]] || [[ -d /workspaces ]]; }

# ---------- devcontainer helpers ----------
dc_up(){
  local repo
  if [[ -f "$PWD/$DEVCONF_REL" || -d "$PWD/.devcontainer" ]]; then
    repo="$PWD"
  else
    repo="$(abs_repo)"; [[ -n "$repo" ]] || { echo "Repo not found: $MAIN_REPO_ROOT" >&2; exit 1; }
  fi
  require "$DEVCONTAINER_BIN"
  cd "$repo"
  "$DEVCONTAINER_BIN" up --workspace-folder . --config "$DEVCONF_REL" >/dev/null
}

dc_exec(){
  local repo
  if [[ -f "$PWD/$DEVCONF_REL" || -d "$PWD/.devcontainer" ]]; then
    repo="$PWD"
  else
    repo="$(abs_repo)"; [[ -n "$repo" ]] || { echo "Repo not found: $MAIN_REPO_ROOT" >&2; exit 1; }
  fi
  require "$DEVCONTAINER_BIN"
  cd "$repo"
  "$DEVCONTAINER_BIN" exec --workspace-folder . --config "$DEVCONF_REL" bash -lc "$*"
}

enter_shell(){
  if in_container; then
    exec "${SHELL:-bash}" -l
  else
    dc_up
    local term="${TERM:-xterm-256color}"
    # Start a login shell inside the devcontainer using the common exec helper.
    # Expand ${SHELL} inside the container, not on host.
    dc_exec "export TERM='$term'; exec \${SHELL:-bash} -l"
  fi
}

# ---------- git/worktree helpers ----------
slugify(){ local s="$1"; s="${s//\//-}"; s="${s//[^A-Za-z0-9._-]/-}"; printf "%s" "$s"; }
worktree_path_for(){ printf "%s/%s" "$AGENTS_ROOT" "$(slugify "$1")"; }
git_fetch_all(){ git -C "$MAIN_REPO_ROOT" fetch --all -p >/dev/null 2>&1 || true; }
has_local(){ git -C "$MAIN_REPO_ROOT" show-ref --verify --quiet "refs/heads/$1"; }
has_remote(){ [[ $(git -C "$MAIN_REPO_ROOT" ls-remote --heads origin "$1" | wc -l | tr -d ' ') -gt 0 ]]; }
resolve_pr(){ command -v gh >/dev/null 2>&1 && gh pr view "$1" --json headRefName --jq '.headRefName' 2>/dev/null || true; }

ensure_wt(){ local branch="$1"; local slug="$(slugify "$branch")"; local wt="$(worktree_path_for "$slug")"; git_fetch_all; if [[ ! -d "$wt" ]]; then mkdir -p "$AGENTS_ROOT"; if has_local "$branch"; then git -C "$MAIN_REPO_ROOT" worktree add -f "$wt" "$branch"; elif has_remote "$branch"; then git -C "$MAIN_REPO_ROOT" worktree add -f -B "$branch" "$wt" "origin/$branch"; else local base; if git -C "$MAIN_REPO_ROOT" rev-parse --verify origin/main >/dev/null 2>&1; then base=origin/main; else base=main; fi; git -C "$MAIN_REPO_ROOT" worktree add -f -b "$branch" "$wt" "$base"; fi; fi; cd "$wt" && pwd; }

run_setup(){ local wt="$1"; if command -v uv >/dev/null 2>&1; then (cd "$wt" && uv sync --extra dev >/dev/null) || (cd "$wt" && uv sync --extra dev); fi; }

list_wt(){ git_fetch_all; echo "Worktrees under $AGENTS_ROOT:"; [[ -d "$AGENTS_ROOT" ]] || { echo "(none)"; return; } ; find "$AGENTS_ROOT" -maxdepth 1 -mindepth 1 -type d -print0 | sort -z | while IFS= read -r -d '' p; do local slug="$(basename "$p")"; local br="$(git -C "$p" rev-parse --abbrev-ref HEAD 2>/dev/null || echo '?')"; echo "- $slug branch=$br"; done; }

remove_wt(){ local token="$1" force="$2"; local slug="$(slugify "$token")"; local wt="$(worktree_path_for "$slug")"; local br="$token"; if [[ -d "$wt" ]]; then br=$(git -C "$wt" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "$token"); local dirty=0; [[ -n "$(git -C "$wt" status --porcelain 2>/dev/null)" ]] && dirty=1; [[ $dirty -eq 1 && $force -ne 1 ]] && { echo "Refusing to remove dirty worktree: $wt (use --force)" >&2; return 1; }; git -C "$MAIN_REPO_ROOT" worktree remove ${force:+--force} "$wt" || true; if git -C "$MAIN_REPO_ROOT" show-ref --verify --quiet "refs/heads/$br"; then [[ $force -eq 1 ]] && git -C "$MAIN_REPO_ROOT" branch -D "$br" || git -C "$MAIN_REPO_ROOT" branch -d "$br" || true; fi; fi }

gc_wt(){ local force="$1"; declare -A ACTIVE; while IFS= read -r p; do ACTIVE["$p"]=1; done < <(git -C "$MAIN_REPO_ROOT" worktree list --porcelain | awk '/^worktree /{print $2}'); if [[ -d "$AGENTS_ROOT" ]]; then find "$AGENTS_ROOT" -maxdepth 1 -mindepth 1 -type d -print0 | while IFS= read -r -d '' d; do [[ -z "${ACTIVE["$d"]+x}" ]] && { echo "[gc] orphan: $d"; [[ $force -eq 1 ]] && rm -rf "$d"; }; done; fi; }

# ---------- parse flags ----------
force=0; do_connect=0; do_ssh=0; do_up=0; do_shell=0; do_list=0; do_gc=0; do_codex=0
open_token=""; create_branch=""; remove_token=""; exec_cmd=""; codex_args=()

while [[ $# -gt 0 ]]; do case "$1" in
  --connect) do_connect=1; shift ;;
  --ssh) do_ssh=1; shift ;;
  --up) do_up=1; shift ;;
  --shell) do_shell=1; shift ;;
  --exec) shift; exec_cmd="${1:-}"; [[ -n "$exec_cmd" ]] || { echo "--exec needs a command" >&2; exit 2; }; shift ;;
  --codex) shift; do_codex=1; codex_args=("$@"); set -- ;; # consume rest at run time
  --list) do_list=1; shift ;;
  --open) shift; open_token="${1:-}"; [[ -n "$open_token" ]] || { echo "--open needs token (branch or pr:NUM)" >&2; exit 2; }; shift ;;
  --create) shift; create_branch="${1:-}"; [[ -n "$create_branch" ]] || { echo "--create needs branch" >&2; exit 2; }; shift ;;
  --remove) shift; remove_token="${1:-}"; [[ -n "$remove_token" ]] || { echo "--remove needs token" >&2; exit 2; }; shift ;;
  --gc) do_gc=1; shift ;;
  --force) force=1; shift ;;
  --doctor) print_cfg; echo "--- tools ---"; for b in ssh "$DEVCONTAINER_BIN" bash git; do printf '%-14s ' "$b"; command -v "$b" || true; done; echo; exit 0 ;;
  --env) print_cfg; exit 0 ;;
  -h|--help) usage; exit 0 ;;
  *) echo "Unknown arg: $1" >&2; usage; exit 1 ;;
esac; done

# ---------- connect (immediate) ----------
if (( do_connect )); then if (( USE_MOSH_DEFAULT )); then if command -v mosh >/dev/null 2>&1; then exec mosh --ssh="ssh" "$HOST_ALIAS"; else echo "[info] mosh not installed; falling back to ssh"; exec ssh "$HOST_ALIAS"; fi; else exec ssh "$HOST_ALIAS"; fi; fi
if (( do_ssh )); then exec ssh "$HOST_ALIAS"; fi

# ---------- worktree queries ----------
if (( do_list )); then list_wt; fi

# ---------- worktree mutations ----------
if [[ -n "$create_branch" ]]; then [[ "$create_branch" == main ]] && { echo "Refuse to manage 'main'" >&2; exit 1; }; require git; wt="$(ensure_wt "$create_branch")"; run_setup "$wt"; cd "$wt" || exit 1; fi
if [[ -n "$open_token" ]]; then require git; token="$open_token"; if [[ "$token" == pr:* ]]; then prn="${token#pr:}"; token="$(resolve_pr "$prn")"; [[ -n "$token" ]] || { echo "Cannot resolve PR #$prn" >&2; exit 1; }; fi; [[ "$token" == main ]] && { echo "Refuse to manage 'main'" >&2; exit 1; }; wt="$(ensure_wt "$token")"; run_setup "$wt"; cd "$wt" || exit 1; fi
if [[ -n "$remove_token" ]]; then remove_wt "$remove_token" "$force"; fi
if (( do_gc )); then gc_wt "$force"; fi

# ---------- container ops ----------
if (( do_up )); then dc_up; fi
if [[ -n "$exec_cmd" ]]; then dc_exec "$exec_cmd"; fi
if (( do_codex )); then
  cmd="$CODEX_CMD_DEFAULT"
  if [[ ${#codex_args[@]} -gt 0 ]]; then cmd+=" ${codex_args[*]}"; fi
  if in_container; then export TERM="${TERM:-xterm-256color}"; exec bash -lc "$cmd"; else dc_exec "$cmd"; fi
fi
if (( do_shell )); then enter_shell; fi

# If nothing executed, show help
if ! { (( do_list || do_gc || do_up || do_shell || do_codex )) || [[ -n "$exec_cmd$remove_token$create_branch$open_token" ]]; }; then usage; fi
