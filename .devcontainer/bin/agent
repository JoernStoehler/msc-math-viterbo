#!/usr/bin/env bash
set -euo pipefail

# agent — unified CLI for *this repo only* (no env/config required)
# Repo: ~/workspaces/msc-math-viterbo
# Host alias (ssh config): joern-pc
# No tmux. Works the same on phone (Termux) and Ubuntu host.
#
# Examples:
#   agent --connect                  # phone → mosh/ssh joern-pc
#   agent --up --shell               # ensure devcontainer, enter shell
#   agent --open feat-123 --codex    # ensure worktree, then run Codex inside container
#   agent --open pr:42 --shell       # open by PR number
#   agent --create exp-foo --shell   # new branch from main
#   agent --exec "pytest -q"         # one-off in container
#   agent --list                     # list worktrees
#   agent --remove feat-123 --force  # delete worktree/branch

# ---------- fixed repo/host settings (YAGNI: no env, no multi-repo) ----------
HOST_ALIAS="joern-pc"                          # must match ~/.ssh/config
MAIN_REPO_ROOT="$HOME/workspaces/msc-math-viterbo"
DEVCONF_REL=".devcontainer/local/devcontainer.json"
DEVCONTAINER_BIN="devcontainer"
CODEX_CMD_DEFAULT="codex --yolo --model gpt-5 --config model_reasoning_effort=high"
USE_MOSH_DEFAULT=1                              # use mosh on phone

# Computes writable agents root: prefer /workspaces (inside container), else .. near repo
choose_agents_root(){
  if [[ -d /workspaces && -w /workspaces ]]; then
    echo "/workspaces/msc-math-viterbo.agents"
  else
    echo "$MAIN_REPO_ROOT/../msc-math-viterbo.agents"
  fi
}
AGENTS_ROOT="$(choose_agents_root)"; mkdir -p "$AGENTS_ROOT" 2>/dev/null || true

# ---------- helpers ----------
usage(){ cat <<'EOF'
Usage: agent [flags]

Connect (phone; executes immediately):
  --connect            Connect via mosh (falls back to ssh if mosh missing)
  --ssh                Connect via plain ssh

Worktrees:
  --list               List worktrees under msc-math-viterbo.agents
  --open TOKEN         Ensure worktree exists and cd into it (TOKEN or pr:NUM)
  --create BRANCH      Create new branch+worktree from main
  --remove TOKEN       Remove worktree/branch (use with --force for dirty)
  --gc                 Remove orphaned dirs under agents root (use with --force)

Devcontainer actions (chainable, run after worktree ops):
  --up                 Ensure devcontainer is up for current worktree (or MAIN)
  --shell              Enter login shell inside the devcontainer
  --exec CMD           Run command in container and exit
  --codex [ARGS...]    Launch Codex in container (default: codex --yolo --model gpt-5 --config model_reasoning_effort=high)

Tunnel (opinionated):
  --tunnel             Ensure a VS Code Tunnel is running (background/nohup)
  --tunnel-bg          Start tunnel in background (nohup)
  --tunnel-tmux        Start tunnel in tmux (detached)
  --tunnel-kill        Stop any running tunnel and prune stale state

Other:
  --force              Force for remove/gc
  --doctor             Check tools/paths
  --env                Print derived config
  -h, --help           Show help
EOF
}

is_termux(){ [[ "${PREFIX-}" == */com.termux/* ]]; }
require(){ command -v "$1" >/dev/null 2>&1 || { echo "ERROR: missing tool: $1" >&2; exit 127; }; }
abs_repo(){ cd "$MAIN_REPO_ROOT" 2>/dev/null && pwd; }
print_cfg(){ cat <<EOF
whoami=$(whoami)
HOST_ALIAS=$HOST_ALIAS
MAIN_REPO_ROOT=$MAIN_REPO_ROOT
DEVCONF_REL=$DEVCONF_REL
DEVCONTAINER_BIN=$DEVCONTAINER_BIN
AGENTS_ROOT=$AGENTS_ROOT
EOF
}


in_container(){ [[ -f /.dockerenv ]] || [[ -n "${DEVCONTAINER:-}" ]] || [[ -d /workspaces ]]; }

# ---------- tunnel helpers ----------
install_tunnel_cli(){
  # Single, explicit path: install the standalone VS Code CLI from Microsoft CDN
  local arch; arch="$(uname -m)"
  local os_flavor="cli-linux-x64"
  if [[ "$arch" == "aarch64" || "$arch" == "arm64" ]]; then os_flavor="cli-linux-arm64"; fi
  if in_container; then
    if command -v code >/dev/null 2>&1 && code --help 2>/dev/null | grep -q "tunnel"; then
      return 0
    fi
    echo "[agent] Installing VS Code CLI"
    mkdir -p "$HOME/.local/bin"
    export PATH="$HOME/.local/bin:$PATH"
    local url="https://update.code.visualstudio.com/latest/${os_flavor}/stable"
    local tmpdir; tmpdir="$(mktemp -d)"
    (curl -fsSLo "${tmpdir}/cli.tar.gz" "$url" && tar -xzf "${tmpdir}/cli.tar.gz" -C "$tmpdir" code && install -m 0755 "${tmpdir}/code" "$HOME/.local/bin/code") || true
    rm -rf "$tmpdir"
    command -v code >/dev/null 2>&1 && code --help 2>/dev/null | grep -q "tunnel"
  else
    # Ensure inside-container install
    dc_exec "bash -lc 'if ! command -v code >/dev/null 2>&1 || ! code --help 2>/dev/null | grep -q tunnel; then mkdir -p \$HOME/.local/bin; url=https://update.code.visualstudio.com/latest/${os_flavor}/stable; tmp=\$(mktemp -d); curl -fsSLo \"\$tmp/cli.tar.gz\" \"\$url\" && tar -xzf \"\$tmp/cli.tar.gz\" -C \"\$tmp\" code && install -m 0755 \"\$tmp/code\" \"\$HOME/.local/bin/code\"; rm -rf \"\$tmp\"; fi'"
  fi
}

tunnel_is_logged_in(){
  if in_container; then
    # Prints 'not logged in' when unauthenticated
    local out; out="$(code tunnel user show 2>/dev/null || true)"; [[ "$out" != *"not logged in"* ]]
  else
    dc_exec "out=\$(code tunnel user show 2>/dev/null || true); [[ \"$out\" != *not logged in* ]]"
  fi
}

tunnel_default_name(){
  local name
  if [[ -n "${open_token:-}" ]]; then
    name="$(slugify "$open_token")"
  elif [[ -d .git ]]; then
    name="$(basename "$(pwd)")"
  else
    name="$(hostname -s 2>/dev/null || echo vsc)"
  fi
  printf "%s" "$name"
}

# Returns 0 only if a tunnel is Connected (not just CLI present)
tunnel_is_running(){
  if in_container; then
    code tunnel status 2>/dev/null | grep -q '"tunnel":"Connected"'
  else
    dc_exec "code tunnel status 2>/dev/null | grep -q '\\"tunnel\\":\\"Connected\\"'"
  fi
}

tunnel_start(){
  local name="$1" mode="$2"
  # Always pass explicit CLI data dir to avoid env/path surprises
  local cli_dir="${VSCODE_CLI_DATA_DIR:-$HOME/.vscode/cli}"
  local cmd="code --cli-data-dir \"$cli_dir\" tunnel --accept-server-license-terms --name $name"
  if in_container; then
    case "$mode" in
      tmux)
        if command -v tmux >/dev/null 2>&1; then
          tmux new -d -s vsc-tunnel "$cmd"
          echo "[agent] Tunnel started in tmux session 'vsc-tunnel'"
        else
          echo "[agent] tmux not found; starting in foreground" >&2
          exec bash -lc "$cmd"
        fi
        ;;
      bg)
        nohup bash -lc "$cmd" >/dev/null 2>&1 &
        echo "[agent] Tunnel started in background (nohup)"
        ;;
      *)
        exec bash -lc "$cmd"
        ;;
    esac
  else
    case "$mode" in
      tmux) dc_exec "tmux new -d -s vsc-tunnel '$cmd'" ; echo "[agent] Tunnel started in tmux (container)" ;;
      bg)   dc_exec "nohup bash -lc '$cmd' >/dev/null 2>&1 &" ; echo "[agent] Tunnel started in background (container)" ;;
      *)    dc_exec "$cmd" ;;
    esac
  fi
}

# ---------- devcontainer helpers ----------
dc_up(){
  local repo
  if [[ -f "$PWD/$DEVCONF_REL" || -d "$PWD/.devcontainer" ]]; then
    repo="$PWD"
  else
    repo="$(abs_repo)"; [[ -n "$repo" ]] || { echo "Repo not found: $MAIN_REPO_ROOT" >&2; exit 1; }
  fi
  require "$DEVCONTAINER_BIN"
  cd "$repo"
  "$DEVCONTAINER_BIN" up --workspace-folder . --config "$DEVCONF_REL" >/dev/null
}

dc_exec(){
  local repo
  if [[ -f "$PWD/$DEVCONF_REL" || -d "$PWD/.devcontainer" ]]; then
    repo="$PWD"
  else
    repo="$(abs_repo)"; [[ -n "$repo" ]] || { echo "Repo not found: $MAIN_REPO_ROOT" >&2; exit 1; }
  fi
  require "$DEVCONTAINER_BIN"
  cd "$repo"
  "$DEVCONTAINER_BIN" exec --workspace-folder . --config "$DEVCONF_REL" bash -lc "$*"
}

enter_shell(){
  if in_container; then
    exec "${SHELL:-bash}" -l
  else
    dc_up
    local term="${TERM:-xterm-256color}"
    # Start a login shell inside the devcontainer using the common exec helper.
    # Expand ${SHELL} inside the container, not on host.
    dc_exec "export TERM='$term'; exec \${SHELL:-bash} -l"
  fi
}

# ---------- git/worktree helpers ----------
slugify(){ local s="$1"; s="${s//\//-}"; s="${s//[^A-Za-z0-9._-]/-}"; printf "%s" "$s"; }
worktree_path_for(){ printf "%s/%s" "$AGENTS_ROOT" "$(slugify "$1")"; }
git_fetch_all(){ git -C "$MAIN_REPO_ROOT" fetch --all -p >/dev/null 2>&1 || true; }
has_local(){ git -C "$MAIN_REPO_ROOT" show-ref --verify --quiet "refs/heads/$1"; }
has_remote(){ [[ $(git -C "$MAIN_REPO_ROOT" ls-remote --heads origin "$1" | wc -l | tr -d ' ') -gt 0 ]]; }
resolve_pr(){ command -v gh >/dev/null 2>&1 && gh pr view "$1" --json headRefName --jq '.headRefName' 2>/dev/null || true; }

ensure_wt(){ local branch="$1"; local slug="$(slugify "$branch")"; local wt="$(worktree_path_for "$slug")"; git_fetch_all; if [[ ! -d "$wt" ]]; then mkdir -p "$AGENTS_ROOT"; if has_local "$branch"; then git -C "$MAIN_REPO_ROOT" worktree add -f "$wt" "$branch"; elif has_remote "$branch"; then git -C "$MAIN_REPO_ROOT" worktree add -f -B "$branch" "$wt" "origin/$branch"; else local base; if git -C "$MAIN_REPO_ROOT" rev-parse --verify origin/main >/dev/null 2>&1; then base=origin/main; else base=main; fi; git -C "$MAIN_REPO_ROOT" worktree add -f -b "$branch" "$wt" "$base"; fi; fi; cd "$wt" && pwd; }

run_setup(){ local wt="$1"; if command -v uv >/dev/null 2>&1; then (cd "$wt" && uv sync --extra dev >/dev/null) || (cd "$wt" && uv sync --extra dev); fi; }

list_wt(){ git_fetch_all; echo "Worktrees under $AGENTS_ROOT:"; [[ -d "$AGENTS_ROOT" ]] || { echo "(none)"; return; } ; find "$AGENTS_ROOT" -maxdepth 1 -mindepth 1 -type d -print0 | sort -z | while IFS= read -r -d '' p; do local slug="$(basename "$p")"; local br="$(git -C "$p" rev-parse --abbrev-ref HEAD 2>/dev/null || echo '?')"; echo "- $slug branch=$br"; done; }

remove_wt(){ local token="$1" force="$2"; local slug="$(slugify "$token")"; local wt="$(worktree_path_for "$slug")"; local br="$token"; if [[ -d "$wt" ]]; then br=$(git -C "$wt" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "$token"); local dirty=0; [[ -n "$(git -C "$wt" status --porcelain 2>/dev/null)" ]] && dirty=1; [[ $dirty -eq 1 && $force -ne 1 ]] && { echo "Refusing to remove dirty worktree: $wt (use --force)" >&2; return 1; }; git -C "$MAIN_REPO_ROOT" worktree remove ${force:+--force} "$wt" || true; if git -C "$MAIN_REPO_ROOT" show-ref --verify --quiet "refs/heads/$br"; then [[ $force -eq 1 ]] && git -C "$MAIN_REPO_ROOT" branch -D "$br" || git -C "$MAIN_REPO_ROOT" branch -d "$br" || true; fi; fi }

gc_wt(){ local force="$1"; declare -A ACTIVE; while IFS= read -r p; do ACTIVE["$p"]=1; done < <(git -C "$MAIN_REPO_ROOT" worktree list --porcelain | awk '/^worktree /{print $2}'); if [[ -d "$AGENTS_ROOT" ]]; then find "$AGENTS_ROOT" -maxdepth 1 -mindepth 1 -type d -print0 | while IFS= read -r -d '' d; do [[ -z "${ACTIVE["$d"]+x}" ]] && { echo "[gc] orphan: $d"; [[ $force -eq 1 ]] && rm -rf "$d"; }; done; fi; }

# ---------- parse flags ----------
force=0; do_connect=0; do_ssh=0; do_up=0; do_shell=0; do_list=0; do_gc=0; do_codex=0
do_tunnel=0; do_tunnel_bg=0; do_tunnel_tmx=0; do_tunnel_kill=0
open_token=""; create_branch=""; remove_token=""; exec_cmd=""; codex_args=()

while [[ $# -gt 0 ]]; do case "$1" in
  --connect) do_connect=1; shift ;;
  --ssh) do_ssh=1; shift ;;
  --up) do_up=1; shift ;;
  --shell) do_shell=1; shift ;;
  --exec) shift; exec_cmd="${1:-}"; [[ -n "$exec_cmd" ]] || { echo "--exec needs a command" >&2; exit 2; }; shift ;;
  --codex) shift; do_codex=1; codex_args=("$@"); set -- ;; # consume rest at run time
  --tunnel) do_tunnel=1; shift ;;
  --tunnel-bg) do_tunnel_bg=1; shift ;;
  --tunnel-tmux) do_tunnel_tmx=1; shift ;;
  --tunnel-kill) do_tunnel_kill=1; shift ;;
  --list) do_list=1; shift ;;
  --open) shift; open_token="${1:-}"; [[ -n "$open_token" ]] || { echo "--open needs token (branch or pr:NUM)" >&2; exit 2; }; shift ;;
  --create) shift; create_branch="${1:-}"; [[ -n "$create_branch" ]] || { echo "--create needs branch" >&2; exit 2; }; shift ;;
  --remove) shift; remove_token="${1:-}"; [[ -n "$remove_token" ]] || { echo "--remove needs token" >&2; exit 2; }; shift ;;
  --gc) do_gc=1; shift ;;
  --force) force=1; shift ;;
  --doctor) print_cfg; echo "--- tools ---"; for b in ssh "$DEVCONTAINER_BIN" bash git; do printf '%-14s ' "$b"; command -v "$b" || true; done; echo; exit 0 ;;
  --env) print_cfg; exit 0 ;;
  -h|--help) usage; exit 0 ;;
  *) echo "Unknown arg: $1" >&2; usage; exit 1 ;;
esac; done

# ---------- connect (immediate) ----------
if (( do_connect )); then if (( USE_MOSH_DEFAULT )); then if command -v mosh >/dev/null 2>&1; then exec mosh --ssh="ssh" "$HOST_ALIAS"; else echo "[info] mosh not installed; falling back to ssh"; exec ssh "$HOST_ALIAS"; fi; else exec ssh "$HOST_ALIAS"; fi; fi
if (( do_ssh )); then exec ssh "$HOST_ALIAS"; fi

# ---------- worktree queries ----------
if (( do_list )); then list_wt; fi

# ---------- worktree mutations ----------
if [[ -n "$create_branch" ]]; then [[ "$create_branch" == main ]] && { echo "Refuse to manage 'main'" >&2; exit 1; }; require git; wt="$(ensure_wt "$create_branch")"; run_setup "$wt"; cd "$wt" || exit 1; fi
if [[ -n "$open_token" ]]; then require git; token="$open_token"; if [[ "$token" == pr:* ]]; then prn="${token#pr:}"; token="$(resolve_pr "$prn")"; [[ -n "$token" ]] || { echo "Cannot resolve PR #$prn" >&2; exit 1; }; fi; [[ "$token" == main ]] && { echo "Refuse to manage 'main'" >&2; exit 1; }; wt="$(ensure_wt "$token")"; run_setup "$wt"; cd "$wt" || exit 1; fi
if [[ -n "$remove_token" ]]; then remove_wt "$remove_token" "$force"; fi
if (( do_gc )); then gc_wt "$force"; fi

# ---------- container ops ----------
if (( do_up )); then dc_up; fi
if [[ -n "$exec_cmd" ]]; then dc_exec "$exec_cmd"; fi
if (( do_codex )); then
  cmd="$CODEX_CMD_DEFAULT"
  if [[ ${#codex_args[@]} -gt 0 ]]; then cmd+=" ${codex_args[*]}"; fi
  if in_container; then export TERM="${TERM:-xterm-256color}"; exec bash -lc "$cmd"; else dc_exec "$cmd"; fi
fi
if (( do_shell )); then enter_shell; fi

# ---------- tunnel kill (explicit cleanup) ----------
if (( do_tunnel_kill )); then
  if in_container; then
    code tunnel kill >/dev/null 2>&1 || true
    code tunnel prune >/dev/null 2>&1 || true
    pkill -f "code( |$).*tunnel" >/dev/null 2>&1 || true
  else
    dc_exec "code tunnel kill >/dev/null 2>&1 || true" || true
    dc_exec "code tunnel prune >/dev/null 2>&1 || true" || true
    dc_exec "pkill -f 'code( |$).*tunnel' >/dev/null 2>&1 || true" || true
  fi
  echo "[agent] Tunnel processes stopped and servers pruned"
fi

# ---------- tunnel op (opinionated) ----------
if (( do_tunnel || do_tunnel_bg || do_tunnel_tmx )); then
  install_tunnel_cli || true
    name="$(tunnel_default_name)"
  # Resolve desired mode: CLI flag > env > default
  mode=""
  if (( do_tunnel_bg )); then mode="bg"; fi
  if (( do_tunnel_tmx )); then mode="tmux"; fi
  if [[ -z "$mode" && -n "${VSC_TUNNEL_MODE:-}" ]]; then
    case "$VSC_TUNNEL_MODE" in
      bg|BG|background) mode="bg" ;;
      tmux|TMUX)        mode="tmux" ;;
    esac
  fi
  if [[ -z "$mode" ]]; then
    mode="bg"
  fi
  if ! tunnel_is_logged_in; then
    echo "[agent] VS Code CLI not logged in. Run: code tunnel user login --provider github" >&2
    exit 1
  elif tunnel_is_running; then
    echo "[agent] VS Code Tunnel is running. Name: $name"
  else
    # If a tunnel process exists but is not connected, cleanly stop it to avoid stale singletons
    if in_container; then
      code tunnel kill >/dev/null 2>&1 || true
      code tunnel prune >/dev/null 2>&1 || true
      # Hard-kill any stray tunnel clients if singleton was confused
      pkill -f "code( |$).*tunnel" >/dev/null 2>&1 || true
    else
      dc_exec "code tunnel kill >/dev/null 2>&1 || true" || true
      dc_exec "code tunnel prune >/dev/null 2>&1 || true" || true
      dc_exec "pkill -f 'code( |$).*tunnel' >/dev/null 2>&1 || true" || true
    fi
    tunnel_start "$name" "$mode"
  fi
  # Briefly wait for connection and report status
  connected=0
  for _ in 1 2 3 4 5; do
    if tunnel_is_running; then connected=1; break; fi
    sleep 1
  done
  if (( connected )); then
    echo "[agent] Tunnel connected. Open: https://vscode.dev/tunnel/$name"
  else
    echo "[agent] Tunnel starting (not connected yet). Check: code tunnel status"
  fi
fi

# If nothing executed, show help
if ! { (( do_list || do_gc || do_up || do_shell || do_codex || do_tunnel || do_tunnel_bg || do_tunnel_tmx )) || [[ -n "$exec_cmd$remove_token$create_branch$open_token" ]]; }; then usage; fi
